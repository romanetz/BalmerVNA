Новая папка для Q-meter

- нaрисовать новую плату, на которой CS4272 и STM32F405
	- USB --ok
		PA11,PA12 + USB_ON
	- LCD --ok
		SPI2 (PB13, PB14, PB15) 
		4 GPIO пина (LED, RST, DC, CS)
		TFT_MISO - PB14
		TFT_LED -  PC8
		TFT_SCK - PB13
		TFT_MOSI - PB15
		TFT_D_C -  PC7
		TFT_RESET - PC6
		TFT_CS - PB12
		GND
		+3V3

	- выводы для управления Rotary encoder (2 шт+2 кнопки) --ok
		энкодеры PA0,PA1, PA6, PA7
	- DAC OUT - PA4
	- выводы для управления AD9959 --ok
		6 пинов надо любых
		пропробовать развести как в плате AD9959, чтобы шлейф воткнуть и не париться
		PB0, PB1, PB2, PB10, PB11, PC5

		AD_CSB - PB11 *
		AD_IO_UPDATE - PB10 *
		AD_SCLK - PB2 *
		AD_SDIO_0 - PB1 *
		AD_PWR_DWN - PB0 *
		AD_RESET - PC5 *

	- GPIO несколько для управления оставшимся оборудованием --ok
		PC0, PC1, PC2, PC3

	- все коннекторы с одной стороны сделать! --ok
	- проверить, что когда убираем L3 между GND и AGND - не стновится больше уровень шумов


con-erni
con-hirose = 0.5mm pitch connector
con-leotronics 1.27 mm SMD
досмотрели до con-omron

Коннектор (слева - верхние, справа - нижние)
PWR_DWN RESET
GND		GND
SDIO_3  SDIO_2
SDIO_1	SDIO_0
DVDD_IO	SCLK
CSB		IO_UPDATE
P3 		P2
P1 		P0

http://www.zoomerpup.com/
http://shop.hellofriend.me/

74AC253 - выводы как в FST3253

----------------------------------------
сделать сборку только с дисплеем


- прикрутить кнопки энкодеры/плдумать про интерфейс
- нарисовать входную часть на SA612A
- прикрутить USB

TS464CD SO-14 (AD8684R такой же корпус и цоколевка)

- не забыть прикрутить транзисторы, выключающие ненужные SA612A --ok
- прикрутить еще какой нить транзистор, чтобы вместо трех переключающих проводов - был один --ok
- не забыть про индуктивность на питании --ok
- подумать про сплиттер сигнала, чтобы на высоко и низкочастотную часть поступал


- http://vk.com/video-35812904_166606590?list=3a393e0f11c84ce41e
	12:20 - вверх
	15:00 = туда-сюда

	py27-pyusb 0.4.3

- прикрутить USB --ok
- наладить общение через USB --ok
- проверить пересылку "длинных" пакетов. По 200-400 байт --ok
- не работает переключение питания на RF_INPUT. Включенно срвзу два канала.
- set frequancy --ok
- сделать сэмплирование данных --ok
	- пока отключаем DAC (как ненужную вещь)
	- пока происходит сэмплирование - ничего не выводить на экран
	- после окончания сэмплирования, отсылаем что сэмплирование законченно
	- в начале сэмплирования выводим на экран start, в конце выводим end
	- сэмплируем 

- вывести график отсэмплированный --ok
	синий = Q = reference feq
- попробовать апдейтить частоту сразу двух каналов используя одно
	IOUpdatePulse(); теоретически не должно помочь

- проверить, правильные ли коэффициэнты будут выдаваться при нецелом цикле
	не очень правильные, но при целом еще хуже
	сделали "честную" среднеквадратическую с решением системы линейных уравнений

- вывести фазовый график --ok

- будем решать систему линейных уравнений методом Гаусса --ok

- проверить, что при начале sampling не получится, что буфер переполнился
- перевести код для определения частоты/фазы/амплитуды на C --ok, время выполнения 38 ms
- посмотреть, почему CS4272 не всегда нормально инициализируется --заговнокодили старт SPI перед CS4272, вроде помогло
- откалибровать амплитуду генератора, так чтобы 100 МГц было по амплитуде сравнимо с 1 МГц --cancel
	калиброванное получается 200 на частоте 37 МГц, 221 - на частоте 100 МГц
	смысла особого калибровать нет amax/amin = 1.4, зато все гладко

- измеряем амплитуду сигнала --ok
	100 КГц
	Open = 148.5 mV
	Short = 77.22 mV
	Cтарые, неэкранированные провода 
	TX = 1
		Short Iamplitude= 327107250.9377912 Qamplitude= 785048816.8677005
		Open  Iamplitude= 194708.67547648196 Qamplitude= 870830675.1289358
	TX = 0
		Short Iamplitude= 1725721.9652738243 Qamplitude= 788332075.0791613
		Open  Iamplitude= 307763185.59748596 Qamplitude= 872492795.6794636

	Новые, экранированные провода
	TX = 1
		Short Iamplitude= 328051032.10411286 Qamplitude= 786774098.9659168
		Open  Iamplitude= 194839.5495403517 Qamplitude= 871861452.8609875

	TX = 0
		Short Iamplitude= 1741140.4729477062 Qamplitude= 785899068.679406
		Open  Iamplitude= 307616617.9819121 Qamplitude= 872389742.871732

- сделать команду, которая в ответ возвращает свой ID и номер (для синхронизации)
- вывести среднеквадратичную ошибку как график
- сделать простейший интерфейс на Qt, для удобства использования
- сделать новый блок питания без импульсного DC-DC преобразователя
	запитали аналоговую часть, отношение I/Q улучшилось с -53 dB до -74 dB
	поставили 7805 с радиатором - все равно греется как хрен знает что!

- запчасти
	- LC П-образный фильтр 
		1 MHz 50 Om
		C = 3.2nF
		7.6 mH

		F = 970 KHz
		L = 8.2 uH
		C = 3.3 nF
		C/2 = 1.7 nF

	- затычка 49.9 Ом (желательно подобрать 49.9 или 50.0)
	- проходная затычка, спаянная из двух SMA на плату
	- экранированные провода для соединения модулей внутри прибора

- измерение параметра четырахполюсника.
	https://ru.wikipedia.org/wiki/%D0%A7%D0%B5%D1%82%D1%8B%D1%80%D1%91%D1%85%D0%BF%D0%BE%D0%BB%D1%8E%D1%81%D0%BD%D0%B8%D0%BA
	http://electrono.ru/glava-1/4-1-vyvod-uravnenij-passivnogo-chetyrexpolyusnika

	Сначала простейший вариант:
		U - напряжение на генераторе (всегда считаем его вещественной величиной), между резисторами R16 и R17
		Z - комплексное сопротивление измеряемой детали
		I_R16 - ток через резистор R16 
		I_R16 = I_R22 + I_R19 + I_R14

		U_R16 = U - I_R16*R16
		I_R22 = U_R16/R22

		U_Z - напряжение левее R14
		U_R19 - напряжение левее R19

		U_Z = U_R16 - I_R14*R14
		U_R19 = U_R16 - I_R19*R19

		U_R15 = U_Z-U_R19
		I_R15 = U_R15/R15

		I_R14 = U_Z/Z + U_Z/(R13+R12) + U_R15/R15
		I_R19 = U_R19/R21+U_R19/(R18+R20) - U_R15/R15

		Нам известно U и U_R15
		Неизвестные U_Z, U_R16, U_R19, Z

		U_R15 = I_R19*R19 - I_R14*R14
		I_R14 = U_Z/Z + U_Z/(R13+R12) + I_R15
		I_R19 = U_R19/R21+U_R19/(R18+R20) - I_R15

		I_R16 = I_R22 + I_R19 + I_R14


		Предположим для простоты, что нам известно U и U_Z
		I_R14 = (U_R16 - U_Z)/R16 
		I_R15 = (U_Z - U_R19)/R15
		I_R19 = (U_R16-U_R19)/R19
		I_R21 = U_R19/R21

		I_R16 = U_R16/R22 + (U_R16-U_R19)/R19 + (U_R16 - U_Z)/R16
		I_R16 = U_R16*(1/R22+1/R19+1/R16) - U_R19/R19 - U_Z/R16

		I_R14 = I_Z + I_R15
		I_R19 = -I_R15 + I_R21

		I_R14 + I_R19 = I_Z + I_R21
		(U_R16 - U_Z)/R16 + (U_R16-U_R19)/R19 = U_Z/Z + U_R19/R21
		U_R16*(1/R16+1/R19) - U_R19*(1/R19+1/R21) - U_Z*(1/R16+1/Z) = 0

Начнем решать еще раз систему уравнений, что-то запутались:
	Токи вокруг U_R16
	0 = I_R16 - I_R14 - I_R19 - I_R22
	Токи вокруг U_Z
	0 = I_R14 - I_Z - I_R15
	Токи вокруг U_R19
	0 = I_R19 - I_R21 + I_R15

	Наряжения на резисторах
	I_R16*R16 = U-U_R16
	I_R22*R22 = U_R16
	I_R14*R14 = U_R16-U_Z
	I_R19*R19 = U_R16-U_R19
	I_Z*Z = U_Z
	I_R15*R15 = U_Z - U_R19
	I_R21*R21 = U_R19

	10 уравнений, 10 неизвестных
	I_R16, I_R22, I_R14, I_R19, I_Z, I_R15, I_R21
	U_R16, U_R19, Z

	0 = (U-U_R16)/R16 - (U_R16-U_Z)/R14 - (U_R16-U_R19)/R19 - U_R16/R22	
	0 = (U_R16-U_Z)/R14 - U_Z/Z - (U_Z - U_R19)/R15
	0 = (U_R16-U_R19)/R19 - U_R19/R21 + (U_Z - U_R19)/R15

	3 уравнения, 3 неизвестнык U_R16, U_R19, Z
	0 = U/R16 + U_Z/R14 + U_R16*(-1/R16-1/R14-1/R19-1/R22) + U_R19/R19
	0 = U_Z*(-1/R14-1/Z-1/R15) + U_R16/R14 + U_R19/R15
	0 = U_Z/R15 + U_R16/R19 + U_R19*(-1/R19-1/R21-1/R15)

	C_R16 = 1/R16+1/R14+1/R19+1/R22
	C_Z = 1/R14+1/Z+1/R15
	C_R19 = 1/R19+1/R21+1/R15

	0 = U/R16 + U_Z/R14 - U_R16*C_R16 + U_R19/R19
	0 =-U_Z*C_Z + U_R16/R14 + U_R19/R15
	0 = U_Z/R15 + U_R16/R19 - U_R19*C_R19

	U_R19 = (U_Z/R15 + U_R16/R19)/C_R19

	0 = U/R16 + U_Z/R14 - U_R16*C_R16 + (U_Z/R15 + U_R16/R19)/C_R19/R19

	----
	0 = U/R16 + U_Z*(1/R14+1/(R15*C_R19*R19)) + U_R16*(-C_R16 + 1/(R19*C_R19*R19))
	U_R16 = (U/R16 + U_Z*(1/R14+1/(R15*C_R19*R19)))/(C_R16-1/(R19*C_R19*R19))

	U_Z*C_Z = U_R16/R14 + U_R19/R15

	1/Z = C_Z-1/R14-1/R15
	Z = 1/(1/C_Z_1-1/R14-1/R15)
	Z = C_Z_1/(1-C_Z_1/R14-C_Z_1/R15)

	- Вместо U_Z используем U_R15
	U_Z = U_R19+U_R15

	0 = I_R16 - I_R14 - I_R19 - I_R22
	0 = I_R14 - I_Z - I_R15
	0 = I_R19 - I_R21 + I_R15

	I_R16*R16 = U-U_R16
	I_R22*R22 = U_R16
	I_R14*R14 = U_R16-U_R19-U_R15
	I_R19*R19 = U_R16-U_R19
	I_Z*Z = U_R19+U_R15
	I_R15*R15 = U_R15
	I_R21*R21 = U_R19

	0 = (U-U_R16)/R16 - (U_R16-U_R19-U_R15)/R14 - (U_R16-U_R19)/R19 - U_R16/R22
	0 = (U_R16-U_R19-U_R15)/R14 - (U_R19+U_R15)/Z - U_R15/R15
	0 = (U_R16-U_R19)/R19 - U_R19/R21 + U_R15/R15

	Неизвестные Z, U_R16, U_R19
	Берем первое и третье уравнение
	0 = U_R16*(-1/R16-1/R14-1/R22-1/R19) + U_R19/R14 + U/R16 + U_R15/R14
	0 = U_R16/R19 + U_R19*(-1/R19-1/R21) + U_R15/R15

	C_R16 = 1/R16+1/R14+1/R22+1/R19
	C_R19 = 1/R19+1/R21

	0 = -U_R16*C_R16 + U_R19*(1/R14+1/R19) + U/R16 + U_R15/R14
	0 = U_R16/R19 - U_R19*C_R19 + U_R15/R15

	U_R16 = U_R19*C_R19*R19 - U_R15/R15*R19 = (U_R19*(1/R14+1/R19) + U/R16 + U_R15/R14)/C_R16

	U_R19*(C_R19*R19-(1/R14+1/R19)/C_R16) = (U/R16 + U_R15/R14)/C_R16 + U_R15/R15*R19
	U_R19 = ((U/R16 + U_R15/R14)/C_R16 + U_R15/R15*R19)/(C_R19*R19-(1/R14+1/R19)/C_R16)

	Z = (U_R19+U_R15)/((U_R16-U_R19-U_R15)/R14 - U_R15/R15)

- Снять отраженную волну 10 KHz - 10 MHz --ok
	- Open
	- 1 Ом
	- 100 Ом
	- 50 Ом
	- Short
	- 100 uH 10 KHz = 6.2 Om, 100 KHz = 62 Om, 10 MHz =6.2 KOm 
	- 7.5 nH 100 KHz = 212 Om , 10 MHz 2.12 Om

	open 3.34
	100 Om 1.14

- прикрутить математику отраженной волны
	- КУ DDS (относительное)
		делитель R1 = 510 R2 = 49.9 R2/(R1+R2) = 0.0891
		КУ IC1B R6,R9 = 15k, R5,R11 = 330k R5/R6 = 22
		КУ DDS = 1.96
	- КУ отраженной волны
		делитель R12 = 47, R13 = 470 R12/(R12+R13) = 0.0909
		КУ IC1A R25,R26 = 4.7k, R24,R29 = 330k R24/R25 = 70.2
		КУ отраженной волны = 6.38

	- делим получившиеся амплитуды на КУ, переводим в комплексные напряжения и подставляем в формулу

- Сделать расчет U_R15 от Z и U
	Неизвестные U_R15, U_R16, U_R19
	0 = (U-U_R16)/R16 - (U_R16-U_R19-U_R15)/R14 - (U_R16-U_R19)/R19 - U_R16/R22
	0 = (U_R16-U_R19-U_R15)/R14 - (U_R19+U_R15)/Z - U_R15/R15
	0 = (U_R16-U_R19)/R19 - U_R19/R21 + U_R15/R15

	0 = U_R15/R14 + U_R16*(-1/R16-1/R14-1/R19-1/R22) + U_R19*(1/R14+1/R19) + U/R16
	0 = U_R15*(-1/R14-1/Z-1/R15)  + U_R16/R14 + U_R19*(-1/R14-1/Z)
	0 = U_R15/R15 + U_R16/R19 + U_R19*(-1/R21-1/R19)

	C_R16 = (-1/R16-1/R14-1/R19-1/R22)
	C_R15 = (-1/R14-1/Z-1/R15)

	0 = U_R15/R14 + U_R16*C_R16 + U_R19*(1/R14+1/R19) + U/R16
	0 = U_R15*C_R15 + U_R16/R14 + U_R19*(-1/R14-1/Z)
	0 = U_R15/R15 + U_R16/R19 + U_R19*(-1/R21-1/R19)

	U_R15 = -U_R16*R15/R19 + U_R19*R15*(1/R21+1/R19)
	0 = U_R16*(1/R14-R15/R19*C_R15) + U_R19*(R15*(1/R21+1/R19)*C_R15-1/R14-1/Z)
	0 = U_R16*(C_R16-R15/R19/R14) + U_R19*(1/R14+1/R19+R15*(1/R21+1/R19)/R14) + U/R16

	C00 = (1/R14-R15/R19*C_R15)
	C01 = (R15*(1/R21+1/R19)*C_R15-1/R14-1/Z)
	C10 = (C_R16-R15/R19/R14)
	C11 = (1/R14+1/R19+R15*(1/R21+1/R19)/R14)

	0 = U_R16*C00 + U_R19*C01
	0 = U_R16*C10 + U_R19*C11 + U/R16

	U_R19 = -U_R16*C00/C01
	0 = U_R16*C10 -U_R16*C00/C01*C11 + U/R16
	0 = U_R16*(C10 - C00/C01*C11) + U/R16

	U_R16 = U/R16/(C00/C01*C11-C10)

- сделать расчет для U_R15 от Z=0 и U
	Токи вокруг U_R16
	0 = I_R16 - I_R14 - I_R19 - I_R22
	Токи вокруг U_Z
	0 = I_R14 - I_Z - I_R15
	Токи вокруг U_R19
	0 = I_R19 - I_R21 + I_R15

	Наряжения на резисторах
	I_R16*R16 = U-U_R16
	I_R22*R22 = U_R16
	I_R14*R14 = U_R16-U_Z
	I_R19*R19 = U_R16-U_R19
	I_Z*Z = U_Z
	I_R15*R15 = U_R15
	I_R21*R21 = U_R19

	Z=0 -> U_Z = 0
	U_Z = U_R19+U_R15 -> U_R19 = - U_R15

	I_R16 = (U-U_R16)/R16
	I_R22 = U_R16/R22
	I_R14 = U_R16/R14
	I_R19 = (U_R16+U_R15)/R19
	I_R15 = U_R15/R15
	I_R21 = -U_R15/R21

	0 = (U-U_R16)/R16 - U_R16/R14 - (U_R16+U_R15)/R19 - U_R16/R22
	0 = (U_R16+U_R15)/R19 + U_R15/R21 + U_R15/R15

	0 = U/R16 + U_R16*(-1/R16-1/R14-1/R19-1/R22) - U_R15/R19
	0 = U_R16/R19 + U_R15*(1/R19+1/R21+1/R15)

	C_R16 = 1/R16+1/R14+1/R19+1/R22
	C_R15 = 1/R19+1/R21+1/R15

	0 = U/R16 - U_R16*C_R16 - U_R15/R19
	0 = U_R16/R19 + U_R15*C_R15

	U_R16 = - U_R15*C_R15*R19

	0 = U/R16 + U_R15*C_R15*R19*C_R16 - U_R15/R19
	0 = U/R16 + U_R15*(C_R15*R19*C_R16 - 1/R19)
	U_R15 = - U/R16 / (C_R15*R19*C_R16 - 1/R19)


- посчитать разницу коэффициэнтов усиления на чатоте 10 КГц
	для 0 Ом
		I = 320680206
		Q = 739051838
	для 100 Ом
		I = 110855503
		Q = 857022344
	для open
		I = 326195154
		Q = 916171180

- попробуем минимальную калибровку
	по Open/Short определим KU (будем полагать что это вещественное число)

- разобраться, почему фаза начинается не с 0, а с 0.01 на частоте 10 КГц (при setTX(0))
	непонятно, но явление явно не с алгоритмами связанно 
	- посмотреть на фазу при setTX(1)
	
- 
	https://github.com/bobbl/libaeabi-cortexm0

- переделать цифровую часть на вариант с дифференциальным входом
- нарисовать аналоговый кусочек на AD834 и TS462
	кстати так-как у нас питание будет +-5V то можно будет ограничиться NE5532 
	(хотя тут надо аккуратно, у NE5532 вход зашунтирован диодами может получиться ограничение по динамическому диапазону?)

- нарисовать цифровой кусок с дифференциальным одним входом
	con-garry = 2mm pins
	http://www.itead.cc/open-pcb/pcb-prototyping/2layer-green-pcb-5cm-x-10cm-max.html
	KiCAD

- сделать общение через Serial Port и выводить приходящие данные в виде графиков.
- писать на диск используя PugiXML

https://github.com/balmerdx/BalmerVNA.git

- Serial Port
	Display Detected System's Serial Support
	dmesg | grep tty

	Добавляем себе права обращаться к Serial Port (потом перезагружаемся)
	sudo gpasswd --add jodes dialout
	sudo usermod -a -G dialout balmer

	- open serial port --ok
	- send first command --ok

- прикрутить QCustomPlot --ok
- сделать чтобы команды можно было добавить в очередь --ok
- VnaCommandSamplingComplete - перезапускать, а не удалять из очереди а потом добавлять.
	
usbd_cdc_DataIn

http://habrahabr.ru/post/248729/

- разбираемся с USB Com port --вроде корректно стало работать.
	VCP_fops == APP_FOPS
	usbd_cdc_SOF - посылаем данные.
	usbd_cdc_DataIn - также посылаем данные.

	- сделать простейший циклический буффер на C.
		в этот буфер можно добавлять/удалять данные и проверять isFull/isEmpty

	- не забыть о ZLP (Zero Length Packet) если посылаем пакет максимальной длинны.


	CDC_DATA_MAX_PACKET_SIZE размер пакета
	APP_RX_DATA_SIZE - размер циклического буфера для отсылки данных с девайса на 
компьютер.
	rx_ring
	APP_Rx_send_buffer
	usbd_cdc_DataIn
	Handle_USBAsynchXfer

	USB_Tx_State ==0 - данные не отсылаются
	APP_Rx_send_buffer

	lsusb -v >l - посмотреть на USB дескрипторы

	Приходят команды "AT\0xd"
	Пускай пакеты завершаются не 0xFF а 0x0D

	ModemManager нам посылает лишние команды
	https://pixhawk.org/dev/nuttx/building_and_flashing_console 

	idVendor           0x0483 STMicroelectronics
  echo 'ATTRS{idVendor}=="0483", ENV{ID_MM_DEVICE_IGNORE}="1"' >> /tmp/rule
  sudo mv /tmp/rule /etc/udev/rules.d/20-mm-blacklist-px4.rules && sudo udevadm control --reload-rules

- сделать чтобы автоматом график рисовался после того, как данные прочитали с девайса. --ok

- дописать код для COMMAND_START_SAMPLING_AND_CALCULATE/COMMAND_GET_CALCULATED --ok
- настройки
	минимальная/максимальная частота
	количество точек
	log/linear график
	две шкалы для амплитуды и фазы
- http://docs.kicad-pcb.org/en/getting_started_in_kicad.html
  http://www.kicadlib.org/

- нарисовать платку на 
	AD834 

- промерять фильтры
	10.7Мгц
	450 КГц

